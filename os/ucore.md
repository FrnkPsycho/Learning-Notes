## AT&T汇编基本语法

ucore中用到的是AT&T格式的汇编，与Intel格式的汇编有一些不同。二者语法上主要有以下几个不同：

```
    * 寄存器命名原则
        AT&T: %eax                      Intel: eax
    * 源/目的操作数顺序 
        AT&T: movl %eax, %ebx           Intel: mov ebx, eax
    * 常数/立即数的格式　
        AT&T: movl $_value, %ebx        Intel: mov eax, _value
      把value的地址放入eax寄存器
        AT&T: movl $0xd00d, %ebx        Intel: mov ebx, 0xd00d
    * 操作数长度标识 
        AT&T: movw %ax, %bx             Intel: mov bx, ax
    * 寻址方式 
        AT&T:   immed32(basepointer, indexpointer, indexscale)
        Intel:  [basepointer + indexpointer × indexscale + imm32)
```

如果操作系统工作于保护模式下，用的是32位线性地址，所以在计算地址时不用考虑`segment:offset`的问题。上式中的地址应为：

```
    imm32 + basepointer + indexpointer × indexscale
```

下面是一些例子：

```
    * 直接寻址 
            AT&T:  foo                         Intel: [foo]
            boo是一个全局变量。注意加上$是表示地址引用，不加是表示值引用。对于局部变量，可以通过堆栈指针引用。

    * 寄存器间接寻址 
            AT&T: (%eax)                        Intel: [eax]

    * 变址寻址 
            AT&T: _variable(%eax)               Intel: [eax + _variable]
            AT&T: _array( ,%eax, 4)             Intel: [eax × 4 + _array]
            AT&T: _array(%ebx, %eax,8)          Intel: [ebx + eax × 8 + _array]
```

## qemu

在实验中，例如 lab1，可能用到的命令如：

```
qemu -hda ucore.img -parallel stdio        # 让ucore在qemu模拟的x86硬件环境中执行
```

或

```
qemu -S -s -hda ucore.img -monitor stdio    # 用于与gdb配合进行源码调试
```

## gdb

### 远程调试

```
(gdb)  target remote 127.0.0.1:1234
```

为了让gdb获知符号信息，需要指定调试目标文件，gdb中使用file命令：

```
(gdb)  file ./bin/kernel
```

### 设定调试目标架构

在调试的时候，我们也许需要调试不是i386保护模式的代码，比如8086实模式的代码，我们需要设定当前使用的架构：

```
(gdb) set arch i8086
```

这个方法在调试不同架构或者说不同模式的代码时还是有点用处的。

## 80386架构

三个地址空间：物理地址、线性地址和逻辑地址。物理内存地址空间是处理器提交到总线上用于访问计算机系统中的内存和外设的最终地址。一个计算机系统中只有一个物理地址空间。线性地址空间是80386处理器通过段（Segment）机制控制下的形成的地址空间。在操作系统的管理下，每个运行的应用程序有相对独立的一个或多个内存空间段，每个段有各自的起始地址和长度属性，大小不固定，这样可让多个运行的应用程序之间相互隔离，实现对地址空间的保护。

在操作系统完成对80386处理器段机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立全局描述符表，完成虚拟地址与线性地址的映射关系）后，80386处理器的段管理功能单元负责把虚拟地址转换成线性地址，在没有下面介绍的页机制启动的情况下，这个线性地址就是物理地址。

相对而言，段机制对大量应用程序分散地使用大内存的支持能力较弱。所以Intel公司又加入了页机制，每个页的大小是固定的（一般为4KB），也可完成对内存单元的安全保护，隔离，且可有效支持大量应用程序分散地使用大内存的情况。

在操作系统完成对80386处理器页机制的初始化和配置（主要是需要操作系统通过特定的指令和操作建立页表，完成虚拟地址与线性地址的映射关系）后，应用程序看到的逻辑地址先被处理器中的段管理功能单元转换为线性地址，然后再通过80386处理器中的页管理功能单元把线性地址转换成物理地址。

> 页机制和段机制有一定程度的功能重复，但Intel为了向下兼容等目标，使得这两者一直共存。

上述三种地址的关系如下：

- 分段机制启动、分页机制未启动：逻辑地址--->**段机制处理**--->线性地址=物理地址
- 分段机制和分页机制都启动：逻辑地址--->**段机制处理**--->线性地址--->***页机制处理\***--->物理地址